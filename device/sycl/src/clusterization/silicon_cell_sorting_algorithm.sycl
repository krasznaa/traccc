/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2026 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// Local include(s).
#include "../utils/calculate1DimNdRange.hpp"
#include "../utils/get_queue.hpp"
#include "../utils/oneDPL.hpp"
#include "traccc/sycl/clusterization/silicon_cell_sorting_algorithm.hpp"

// Project include(s).
#include "traccc/clusterization/device/silicon_cell_sorter.hpp"
#include "traccc/clusterization/device/sorting_index_filler.hpp"

namespace traccc::sycl {
namespace kernels {

/// Kernel filling the output buffer with sorted cells.
struct fill_sorted_silicon_cells {};

}  // namespace kernels

silicon_cell_sorting_algorithm::silicon_cell_sorting_algorithm(
    const traccc::memory_resource& mr, vecmem::copy& copy,
    sycl::queue_wrapper& q, std::unique_ptr<const Logger> logger)
    : device::algorithm_base(mr, copy),
      sycl::algorithm_base(q),
      messaging(std::move(logger)) {}

auto silicon_cell_sorting_algorithm::operator()(
    const edm::silicon_cell_collection::const_view& cells_view) const
    -> output_type {

    // Exit early if there are no cells.
    if (cells_view.capacity() == 0) {
        return {};
    }

    // Get the SYCL queue to use for the algorithm.
    ::sycl::queue& squeue = details::get_queue(queue());

    // oneDPL policy to use, forcing execution onto the same device that the
    // hand-written kernels would run on.
    auto policy = oneapi::dpl::execution::device_policy{squeue};

    // Create a vector of cell indices, which would be sorted.
    vecmem::data::vector_buffer<unsigned int> indices(cells_view.capacity(),
                                                      mr().main);
    copy().setup(indices)->wait();
    oneapi::dpl::for_each(policy, indices.ptr(),
                          indices.ptr() + indices.capacity(),
                          device::sorting_index_filler{indices});

    // Sort the indices according to the (correct) order of the cells.
    oneapi::dpl::sort(policy, indices.ptr(), indices.ptr() + indices.capacity(),
                      device::silicon_cell_sorter{cells_view});

    // Create the output buffer.
    output_type result{cells_view.capacity(), mr().main,
                       cells_view.size().capacity()
                           ? vecmem::data::buffer_type::resizable
                           : vecmem::data::buffer_type::fixed_size};
    copy().setup(result)->ignore();
    copy()(cells_view.size(), result.size())->ignore();

    // Fill it with the sorted cells.
    const unsigned int BLOCK_SIZE = warp_size() * 8;
    squeue.submit([&](::sycl::handler& h) {
        h.parallel_for<kernels::fill_sorted_silicon_cells>(
            details::calculate1DimNdRange(cells_view.capacity(), BLOCK_SIZE),
            [input_view = cells_view, output_view = vecmem::get_data(result),
             sorted_indices_view =
                 vecmem::get_data(indices)](::sycl::nd_item<1> item) {
                // Create the device objects.
                const edm::silicon_cell_collection::const_device input{
                    input_view};
                edm::silicon_cell_collection::device output{output_view};
                const vecmem::device_vector<const unsigned int> sorted_indices{
                    sorted_indices_view};

                // Stop early if we can.
                const unsigned int index =
                    static_cast<unsigned int>(item.get_global_id(0));
                if (index >= input.size()) {
                    return;
                }

                // Copy one measurement into the correct position.
                output.at(index) = input.at(sorted_indices.at(index));
            });
    });

    // Return the sorted buffer.
    return result;
}

}  // namespace traccc::sycl
